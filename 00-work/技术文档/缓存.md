# 多级缓存
### 什么是多级缓存
多级缓存是一种**分层存储架构**，旨在通过组合不同存储介质的性能特性，构建成本与速度的最优平衡。
其核心架构通常包含三个层次：
- **L1 本地缓存（进程级）**：基于应用内存（如 Caffeine、Guava）。特点为**极低延迟**，适合拦截超高频热点请求。
- **L2 分布式缓存（集群级）**：基于高速中间件（如 Redis）。特点为**高并发、高可用**，用于在多节点间共享数据，作为本地缓存未命中时的快速回源。
- **L3 持久化存储（服务级）**：基于数据库或对象存储（如 MySQL、MinIO）。特点为**大容量、高可靠**，作为数据的最终落地与兜底保障。
 目标：**以空间换时间，以存储换计算**。用极低的缓存成本，屏蔽掉后端繁重的计算逻辑，实现系统的高吞吐与低延迟。
### 多级缓存与单级缓存的区别
| 维度 | 单级缓存 (Single-Level) | 多级缓存 (Multi-Level) | 核心差异解析 |
| :--- | :--- | :--- | :--- |
| **架构层次** | **扁平化**：仅依赖单一介质（通常为 Redis） | **立体化**：L1(本地) + L2(分布式) + L3(DB) | 多级缓存构建了存储梯度的速度与容量平衡。 |
| **性能 (RT)** | **中等**：受限于网络 I/O 与序列化开销 | **极致**：L1 命中时为内存纳秒级访问 | 多级缓存消除了高频热点数据的网络交互。 |
| **容量扩展** | **有限**：扩容需垂直升级或集群扩容，成本高 | **弹性**：利用 L1 内存存热点，L2 存温数据 | 实现了“小内存抗大流量”的高性价比扩展。 |
| **系统保护** | **单点风险**：缓存宕机直接穿透击垮后端 | **分层防御**：L2 宕机时 L1 仍能抵挡部分洪峰 | 增强了系统的容灾能力与抗雪崩能力。 |
| **命中率策略** | **静态均衡**：无法区分冷热数据 | **动态分层**：热点自动上浮至 L1，冷数据下沉 | 利用 LRU/LFU 算法实现了数据的自动分级存储。 |
### 为什么需要多级缓存
- TMS 瓦片生成开销大（动态渲染或数据合成）
- 用户请求存在热点（城市、景区等）
- 内存容量有限，单层缓存无法覆盖全量瓦片
- 提升响应速度，减轻数据库或原始数据服务压力
### 多级缓存的架构设计
结合 TMS 瓦片服务，常用架构：
1. **内存缓存（第一层）**
    - 存储热点瓦片
    - 快速响应，命中率高
2. **Redis 分布式缓存（第二层）**
    - 热点数据共享，支持集群扩展
    - 适合多节点服务
3. **数据库 / 对象存储（第三层）**
    - 已生成瓦片的持久存储
    - 容量大，支持历史数据和冷数据访问

> **访问流程**：请求 → 内存 → Redis → 数据库 → 原始数据生成
### 缓存策略
- **粒度**：单瓦片 vs 瓦片区域
- **更新策略**：
    - TTL（过期自动刷新）
    - LRU / LFU（热点管理）
    - 主动刷新（数据更新时重新生成瓦片）
- **预生成策略**：
    - 热点区域批量生成
    - 异步任务生成冷数据瓦片
### 技术实现
- **内存缓存**：Caffeine / Guava Cache
    - 优势：极快响应，适合高频请求
    - 劣势：容量有限
- **Redis 缓存**：
    - 集群支持，跨节点共享
    - 支持过期策略、淘汰策略、队列通知刷新
- **数据库 / 持久化存储**：
    - SQL/NoSQL 或对象存储（MinIO、Ceph）
    - 支持长时间存储和历史瓦片查询
### 挑战与应对
#### 缓存一致性
- 瓦片更新时保证各层缓存同步
- 可采用主动更新 + TTL 双重机制
#### 缓存击穿
- 热点瓦片失效瞬间大量请求打到后端
- 解决方案：互斥锁 / 请求排队 / 预生成
#### 缓存雪崩
- 大量缓存同时过期导致瞬时高并发
- 解决方案：过期时间错开、随机 TTL
