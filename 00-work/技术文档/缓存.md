# 多级缓存
### 什么是多级缓存
- 多级缓存是指在系统中使用多层缓存机制来加速数据访问，常见层次包括：
    - **本地缓存**（快速访问、适合高频热点数据）
    - **分布式缓存**（如 Redis，可跨节点共享）
    - **持久化缓存**（数据库或对象存储，用于长期保存）
- 目标：减少后端计算/存储压力，提高响应速度。
### 多级缓存与单级缓存的区别
| 特点  | 单级缓存     | 多级缓存                  |
| --- | -------- | --------------------- |
| 层次  | 单一缓存层    | 多层次缓存，组合使用            |
| 命中率 | 依赖单一缓存容量 | 热点数据优先保存在快速缓存，提高整体命中率 |
| 容量  | 受限于单层容量  | 可通过分层设计扩展总缓存容量        |
| 效率  | 一层失效访问后端 | 一层失效可回退到下一级，减少后端压力    |
### 为什么需要多级缓存
- TMS 瓦片生成开销大（动态渲染或数据合成）
- 用户请求存在热点（城市、景区等）
- 内存容量有限，单层缓存无法覆盖全量瓦片
- 提升响应速度，减轻数据库或原始数据服务压力
### 多级缓存的架构设计
结合 TMS 瓦片服务，常用架构：
1. **内存缓存（第一层）**
    - 存储热点瓦片
    - 快速响应，命中率高
2. **Redis 分布式缓存（第二层）**
    - 热点数据共享，支持集群扩展
    - 适合多节点服务
3. **数据库 / 对象存储（第三层）**
    - 已生成瓦片的持久存储
    - 容量大，支持历史数据和冷数据访问

> **访问流程**：请求 → 内存 → Redis → 数据库 → 原始数据生成
### 缓存策略
- **粒度**：单瓦片 vs 瓦片区域
- **更新策略**：
    - TTL（过期自动刷新）
    - LRU / LFU（热点管理）
    - 主动刷新（数据更新时重新生成瓦片）
- **预生成策略**：
    - 热点区域批量生成
    - 异步任务生成冷数据瓦片
### 技术实现
- **内存缓存**：Caffeine / Guava Cache
    - 优势：极快响应，适合高频请求
    - 劣势：容量有限
- **Redis 缓存**：
    - 集群支持，跨节点共享
    - 支持过期策略、淘汰策略、队列通知刷新
- **数据库 / 持久化存储**：
    - SQL/NoSQL 或对象存储（MinIO、Ceph）
    - 支持长时间存储和历史瓦片查询
### 挑战与应对
#### 缓存一致性
- 瓦片更新时保证各层缓存同步
- 可采用主动更新 + TTL 双重机制
#### 缓存击穿
- 热点瓦片失效瞬间大量请求打到后端
- 解决方案：互斥锁 / 请求排队 / 预生成
#### 缓存雪崩
- 大量缓存同时过期导致瞬时高并发
- 解决方案：过期时间错开、随机 TTL
